---
title: "00_data_input_and_manipulation"
author: "Julia Pop"
date: "2025-07-26"
output: html_document
---

```{r setup, include=FALSE}
# code to troublesheet file path issues. 
# By default, knitr uses the folder containing the .Rmd file as
# the working directory. This code allows us to set the folder
# with our .rProj in it as the root. 

# find_root looks upwards from the .Rmd until it finds a file or
# folder that matches the criteria "folder with a .Rproj file in
# it."

knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::is_rstudio_project))
```

# Notes to self:

1) SIA_run_1_TRK_UFM needs to be rounded to an accurate number of decimal points (after calculations?); same for SIA_run_2_TRK_LFM

## Load packages 
```{r message = false}
source("scripts/libraries.R") # manipulate this file in the scripts folder to add more packages.
```

## Pull in core metadata
```{r, echo = FALSE}
# echo = FALSE shows output but not code. 

# read in bulk density data
bulk_density <- read_excel("data/bulk_density_export_from_sent_to_flett_20250602_saved_20250909.xlsx") %>%
  rename(bd = `bulk_density_g/cm3`)

# read in metadata, join with bd values
TRK_metadata <- read_excel("data/0_TRK2_core_metadata_20250726.xlsx")  %>%
  select(lake_name:depth_bottom) %>%
  left_join(bulk_density %>% 
              select(sample_ID, bd),
            by = "sample_ID")
  
UFM_metadata <- read_excel("data/0_UFM1_core_metadata_20250726.xlsx") %>% 
  select(lake_name:depth_bottom) %>%
  left_join(bulk_density %>% 
              select(sample_ID, bd),
            by = "sample_ID")

LFM_metadata <- read_excel("data/0_LFM2_core_metadata_20250726.xlsx") %>% 
  select(lake_name:depth_bottom) %>%
  left_join(bulk_density %>% 
              select(sample_ID, bd),
            by = "sample_ID")
```

#Stable isotopes

**Note: return later to** 
- round SIA_run1_TRK_UFM to the appropriate number of sig figs
- pull in run 2 and collapse any triplicates, stitch to new file named LFM_SIA!
- add TRK2_002 to TRK_SIA
- consolidate / choose perC.drft or percent.C and the corresponding C:N

```{r, echo = FALSE}
    
# Step One: pull in and clean up IRMS run info
# NOTE: these files (SIA_run1_...SIA_run2_) still contains triplicates!
SIA_run1_TRK_UFM <- read_excel("data/TRK_UFM_SIA_data_clean_20250726.xlsx") %>%
  rename(sample_ID = Identifier1) %>%
  select(sample_ID, d13C.scale, percent.C, perC.drift, d15N.scale, percent.N) %>% # pull in percent.C and perC.drift.
  mutate("C.drift:N" = perC.drift/percent.N,
         "C:N" = percent.C/percent.N) %>%
  rename(d13C = d13C.scale,
         d15N = d15N.scale)

# For now, chose to inlcude both “perC.drift” AND "percent.C" for %C since a very small drift was detected in the HOS lin.std (but either way within the error of 0.3% - where std.dev. is of multiple HOS standard replicates) For now, calculate C:N using both and see how errors propogate. In thesis use percent.C until have a reason not to.

SIA_run2_TRK_LFM <- 
  read_excel("data/TRK_LFM_SIA_data_clean_20250921.xlsx") %>%
    rename(sample_ID = Identifier1) %>%
    select(sample_ID, d13C.scale, linKpercent.C, d15N.scale, perN.drift) %>%
# standardize SIA column names across runs, 
# regardless of corrections used...
    rename(d13C = d13C.scale,
           percent.C = linKpercent.C, 
           d15N = d15N.scale,
           percent.N = perN.drift) %>%
    mutate("C:N" = percent.C/percent.N)

# Step Two: collapse triplicate values, and create a separate SIA spreadsheet for each core (in format: metadata, SIA)

# two a) join dataframes and keep all the observations in TRK_metadata (left, while throwing out any observations from SIA_run1_TRK_UFM, right, that don't have a sample_ID matching those in TRK_metadata). Right now that throws out UFM SIA, but keeps all the extra observations in the left database (e.g. TRK2_001, TRK2_002, TRK2_003...5, 7, 9)

TRK_SIA <- left_join(TRK_metadata, SIA_run1_TRK_UFM, by = "sample_ID") %>%
  select(-perC.drift, -"C.drift:N")

# two b) pull row TRK2_002 to add to the data from run 1 later
row_TRK2_002_SIA <- SIA_run2_TRK_LFM %>%
  filter(sample_ID == "TRK2_002") %>%
  left_join(TRK_metadata, by = "sample_ID") %>%
  relocate(all_of(c(
    "lake_name",
    "core_number",
    "sample_ID",
    "sample_range",
    "depth_top",
    "depth_bottom",
    "d13C",
    "percent.C",
    "d15N",
    "percent.N",
    "C:N"
  ))) # keep columns in the same order.

# two c) do regular cleaning
TRK_SIA <- TRK_SIA %>%
    drop_na() %>% # drop all TRK samples for which we did not run SIA
    group_by(lake_name, core_number, sample_ID, sample_range, depth_top, depth_bottom, bd) %>% # add a step to run the summarize fn on groups of rows (each row could be grouped just by sample_ID, but output would then not include the other metadata; bc metadata should stay the same for duplicate samples, we can use this shortcut). 
    summarize(across(d13C:"C:N", ~mean(.x, na.rm=TRUE)), .groups = "keep") # summarize collapses rows--this fn will take the average of all the triplicates for every row (grouped by the columns above). ".x" is tidyverse's way of saying insert the line before right here when you choose what to take the mean of.

# two d) add row TRK2_002 back in
TRK_SIA <- bind_rows(TRK_SIA, row_TRK2_002_SIA)

# create a UFM stable isotope file. 
UFM_SIA <- left_join(UFM_metadata, SIA_run1_TRK_UFM, by = "sample_ID") %>%
    select(-perC.drift, -"C.drift:N")

# take avg of triplicates
UFM_SIA <- UFM_SIA %>%
    drop_na() %>%
    group_by(lake_name, core_number, sample_ID, sample_range, depth_top, depth_bottom, bd) %>%
    summarize(across(d13C:"C:N", ~mean(.x, na.rm=TRUE)), .groups = "keep")
  
# create an LFM stable isotope file.
LFM_SIA <- left_join(LFM_metadata, SIA_run2_TRK_LFM, by = "sample_ID") %>%
  drop_na() %>%
  group_by(lake_name, core_number, sample_ID, sample_range, depth_top, depth_bottom, bd) %>%
  summarize(across(d13C:"C:N", ~mean(.x, na.rm=TRUE)), .groups = "keep")

# export data for Peter
# write_xlsx(TRK_SIA, path = "output/TRK_SIA_for_leavitt.xlsx")
# write_xlsx(UFM_SIA, path = "output/UFM_SIA_for_leavitt.xlsx")

# clean up Environment: 
rm(row_TRK2_002_SIA)
```

# Pigments
### Pull in pigment data
```{r}

# all raw pigment data is in the units nmol pigment / g total dry mass (code below adds the suffix "_nmol_gDM"). 

UFM_pigments_raw <- read_excel("data/UFM_final_HPLC_20250910.xlsx") %>% 
  select(depth_top, chlide_a:diadino, myxo:car_z) %>%
  rename(b_car = "b-car") %>% 
  rename_with(~paste0(.x, "_nmol_gDM"), .cols = c(chlide_a:car_z))

LFM_pigments_raw <- read_excel("data/LFM_final_HPLC_20250910.xlsx") %>% 
  select(depth_top, chlide_a:diadino, myxo:car_z) %>%
  rename(b_car = "b-car") %>% 
  rename_with(~paste0(.x, "_nmol_gDM"), .cols = c(chlide_a:car_z))

TRK_pigments_raw <- read_excel("data/TRK_final_HPLC_20250910.xlsx") %>% 
  select(depth_top, chlide_a:diadino, myxo:car_z) %>%
  rename(b_car = "b-car") %>% 
  rename_with(~paste0(.x, "_nmol_gDM"), .cols = c(chlide_a:car_z))

# glimpse(UFM_pigments_raw) # 31 pigments total!

```

### Join pigment and SIA dfs
```{r}
# join pigment and sia dfs for each core and add a depth_plot column
UFM_wide <- left_join(UFM_SIA, UFM_pigments_raw, by = "depth_top") %>%
  mutate(depth_plot = depth_top + 0.25) %>%
  relocate(depth_plot, .after = depth_bottom)

TRK_wide <- left_join(TRK_SIA, TRK_pigments_raw, by = "depth_top") %>%
  mutate(depth_plot = depth_top + 0.25) %>%
  relocate(depth_plot, .after = depth_bottom)

TRK_wide <- TRK_wide %>%
  arrange(desc(sample_ID == "TRK2_002"))

LFM_wide <- left_join(LFM_SIA, LFM_pigments_raw, by = "depth_top") %>%
  mutate(depth_plot = depth_top + 0.25) %>%
  relocate(depth_plot, .after = depth_bottom)

# glimpse(UFM_wide)
```

### Recalculate pigment data to compare total DM to TC
```{r}
# to get nmoles / g TC, multiply by 100/percent.C, and add label _nmol_gTC

UFM_wide <- UFM_wide %>%
  # for all the columns that end in _nmol_gDM
  mutate(across(ends_with("_nmol_gDM"), 
  # multiply by (100/percent.C)
  ~ .x * (100/percent.C), 
  # name the new column pigment_scaled
  .names = "{.col}_scaled")) %>%
  
  # rename all scaled columns (and not the original columns) with new unit
  rename_with(~ sub("_nmol_gDM_scaled$", "_nmol_gTC", .x), ends_with("_scaled"))

TRK_wide <- TRK_wide %>%
  mutate(across(ends_with("_nmol_gDM"), 
  ~ .x * (100/percent.C), 
  .names = "{.col}_scaled")) %>%
  rename_with(~ sub("_nmol_gDM_scaled$", "_nmol_gTC", .x), ends_with("_scaled"))

LFM_wide <- LFM_wide %>%
  mutate(across(ends_with("_nmol_gDM"), 
  ~ .x * (100/percent.C), 
  .names = "{.col}_scaled")) %>%
  rename_with(~ sub("_nmol_gDM_scaled$", "_nmol_gTC", .x), ends_with("_scaled"))

```

### Visualize pigment unit differences
```{r}

ggplot(UFM_wide, aes(x = depth_top, y = chl_a_nmol_gDM)) +
  geom_point(size = 2, color = "darkgreen", na.rm = TRUE) +
  geom_line(color = "darkgreen", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Chl-a (nmol/gDM)") +
  theme_minimal()

ggplot(UFM_wide, aes(x = depth_top, y = chl_a_nmol_gTC)) +
  geom_point(size = 2, color = "darkgreen", na.rm = TRUE) +
  geom_line(color = "darkgreen", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Chl-a (nmol/gTC)") +
  theme_minimal()

ggplot(UFM_wide, aes(x = depth_top, y = echine_nmol_gDM)) +
  geom_point(size = 2, color = "green3", na.rm = TRUE) +
  geom_line(color = "green3", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Echinenone (nmol/gDM)") +
  theme_minimal()

ggplot(UFM_wide, aes(x = depth_top, y = echine_nmol_gTC)) +
  geom_point(size = 2, color = "green3", na.rm = TRUE) +
  geom_line(color = "green3", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Echinenone (nmol/gTC)") +
  theme_minimal()

ggplot(UFM_wide, aes(x = depth_top, y = diato_nmol_gDM)) +
  geom_point(size = 2, color = "yellowgreen", na.rm = TRUE) +
  geom_line(color = "yellowgreen", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Diatoxanthin (nmol/gDM)") +
  theme_minimal()

ggplot(UFM_wide, aes(x = depth_top, y = diato_nmol_gTC)) +
  geom_point(size = 2, color = "yellowgreen", na.rm = TRUE) +
  geom_line(color = "yellowgreen", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Diatoxanthin (nmol/gTC)") +
  theme_minimal()

ggplot(TRK_wide, aes(x = depth_top, y = chl_a_nmol_gDM)) +
  geom_point(size = 2, color = "steelblue", na.rm = TRUE) +
  geom_line(color = "steelblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Chl-a (nmol/gDM)") +
  theme_minimal()

ggplot(TRK_wide, aes(x = depth_top, y = chl_a_nmol_gTC)) +
  geom_point(size = 2, color = "steelblue", na.rm = TRUE) +
  geom_line(color = "steelblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Chl-a (nmol/gTC)") +
  theme_minimal()


ggplot(TRK_wide, aes(x = depth_top, y = echine_nmol_gDM)) +
  geom_point(size = 2, color = "blue4", na.rm = TRUE) +
  geom_line(color = "blue4", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Echinenone (nmol/gDM)") +
  theme_minimal()

ggplot(TRK_wide, aes(x = depth_top, y = echine_nmol_gTC)) +
  geom_point(size = 2, color = "blue4", na.rm = TRUE) +
  geom_line(color = "blue4", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Echinenone (nmol/gTC)") +
  theme_minimal()

ggplot(TRK_wide, aes(x = depth_top, y = diato_nmol_gDM)) +
  geom_point(size = 2, color = "royalblue", na.rm = TRUE) +
  geom_line(color = "royalblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Diatoxanthin (nmol/gDM)") +
  theme_minimal()

ggplot(TRK_wide, aes(x = depth_top, y = diato_nmol_gTC)) +
  geom_point(size = 2, color = "royalblue", na.rm = TRUE) +
  geom_line(color = "royalblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Diatoxanthin (nmol/gTC)") +
  theme_minimal()

```

**Pigments missing from every core:** chlide_a, chl_c1, chl_c2, peridinin, sed_a, sed_b, sed_c, oscil, aphan, viola, diadino, myxo, zea, okenone, isoren, a_car, car_x, car_y, car_z

**pigments in every core:** *fuco (drops off in TRK)*, allo, diato, lutein, *cantha (none in TRK)*, chl_b, chl_a, chl_ap, echine, phaeo_b, pheo_a, b_car.

**Pigments focused on in bella's paper:** 
allo, diato, lutein, *cantha*, *myxo*, *zea*, echine, phaeo_b, pheo_a, b_car

**Missing from my data, in Bellas:** myxo, zea, cantha (none in TRK), diadino 

**Consider later:** 
- why is there no diadino? what does that say about diatoms given [diato]...?
- these cores were ~9 months old when analyzed (and experienced more freeze-thaw cycles than is ideal): what do the preservation indices tell us about the reliability of the values we obtained, and or the many zeroes. 
- how can you assess the extent of post-depositional degradation of a given pigment? 
- interpret AD ratio? perc_chlb, etc.
- compare pigments in cyanos with those in vascular plants? no. Per Peter most chl degrades by the time it reaches the water column. 

**Remove from short dfs:** chlide_a, chl_c1, chl_c2, peridinin, sed_a, sed_b, sed_c, oscil, aphan, viola, diadino, myxo, zea, okenone, isoren, a_car, car_x, car_y, car_z

### Clean up dfs, add pigment metrics
```{r}
TRK_short <- TRK_wide %>% # make a new subset df with variables of interest
  select(-ends_with("_gDM"), # remove pigments with g / dry mass unit
         -chlide_a_nmol_gTC, # remove pigments with 0 values 
         -chl_c1_nmol_gTC,
         -chl_c2_nmol_gTC, 
         -perid_nmol_gTC, 
         -sed_a_nmol_gTC, 
         -sed_b_nmol_gTC, 
         -sed_c_nmol_gTC, 
         -oscil_nmol_gTC, 
         -aphan_nmol_gTC, 
         -viola_nmol_gTC, 
         -diadino_nmol_gTC, 
         -myxo_nmol_gTC, 
         -zea_nmol_gTC,
         -okenone_nmol_gTC, 
         -isoren_nmol_gTC, 
         -a_car_nmol_gTC,
         -car_x_nmol_gTC,
         -car_y_nmol_gTC, 
         -car_z_nmol_gTC) %>%
  mutate(chla_pheoa = chl_a_nmol_gTC + pheo_a_nmol_gTC, # add new columns
         chlb_pheob = chl_b_nmol_gTC + phaeo_b_nmol_gTC,
         all_chl = chl_a_nmol_gTC + pheo_a_nmol_gTC + chl_ap_nmol_gTC, # no chlide, chl_c1 or chl_c2 in any core
         # all_diat = diato_nmol_gTC + diadino_nmol_gTC, NO DIADINO
         PI = chl_a_nmol_gTC/pheo_a_nmol_gTC, # preservation index
         # UVR_index = sed_c_nmol_gTC / (allo_nmol_gTC + diato_nmol_gTC+lutein_nmol_gTC)
         # no sed C in any core
         AD_ratio = allo_nmol_gTC / diato_nmol_gTC, 
         master_chl = (chl_a_nmol_gTC + chl_b_nmol_gTC) / (chl_ap_nmol_gTC + pheo_a_nmol_gTC + phaeo_b_nmol_gTC),
         perc_chlb = (phaeo_b_nmol_gTC / pheo_a_nmol_gTC), 
         perc_diatox = (diato_nmol_gTC/chla_pheoa))
    
UFM_short <- UFM_wide %>% # make a new subset df with variables of interest
  select(-ends_with("_gDM"), # remove pigments with g / dry mass unit
         -chlide_a_nmol_gTC, # remove pigments with 0 values 
         -chl_c1_nmol_gTC,
         -chl_c2_nmol_gTC, 
         -perid_nmol_gTC, 
         -sed_a_nmol_gTC, 
         -sed_b_nmol_gTC, 
         -sed_c_nmol_gTC, 
         -oscil_nmol_gTC, 
         -aphan_nmol_gTC, 
         -viola_nmol_gTC, 
         -diadino_nmol_gTC, 
         -myxo_nmol_gTC, 
         -zea_nmol_gTC,
         -okenone_nmol_gTC, 
         -isoren_nmol_gTC, 
         -a_car_nmol_gTC,
         -car_x_nmol_gTC,
         -car_y_nmol_gTC, 
         -car_z_nmol_gTC) %>%
  mutate(chla_pheoa = chl_a_nmol_gTC + pheo_a_nmol_gTC, # add new columns
         chlb_pheob = chl_b_nmol_gTC + phaeo_b_nmol_gTC,
         all_chl = chl_a_nmol_gTC + pheo_a_nmol_gTC + chl_ap_nmol_gTC, # no chlide, chl_c1 or chl_c2 in any core
         # all_diat = diato_nmol_gTC + diadino_nmol_gTC, NO DIADINO
         PI = chl_a_nmol_gTC/pheo_a_nmol_gTC, # preservation index
         # UVR_index = sed_c_nmol_gTC / (allo_nmol_gTC + diato_nmol_gTC+lutein_nmol_gTC)
         # no sed C in any core
         AD_ratio = allo_nmol_gTC / diato_nmol_gTC, 
         master_chl = (chl_a_nmol_gTC + chl_b_nmol_gTC) / (chl_ap_nmol_gTC + pheo_a_nmol_gTC + phaeo_b_nmol_gTC),
         perc_chlb = (phaeo_b_nmol_gTC / pheo_a_nmol_gTC), 
         perc_diatox = (diato_nmol_gTC/chla_pheoa))


# LFM_short
LFM_short <- LFM_wide %>% # make a new subset df with variables of interest
  select(-ends_with("_gDM"), # remove pigments with g / dry mass unit
         -chlide_a_nmol_gTC, # remove pigments with 0 values 
         -chl_c1_nmol_gTC,
         -chl_c2_nmol_gTC, 
         -perid_nmol_gTC, 
         -sed_a_nmol_gTC, 
         -sed_b_nmol_gTC, 
         -sed_c_nmol_gTC, 
         -oscil_nmol_gTC, 
         -aphan_nmol_gTC, 
         -viola_nmol_gTC, 
         -diadino_nmol_gTC, 
         -myxo_nmol_gTC, 
         -zea_nmol_gTC,
         -okenone_nmol_gTC, 
         -isoren_nmol_gTC, 
         -a_car_nmol_gTC,
         -car_x_nmol_gTC,
         -car_y_nmol_gTC, 
         -car_z_nmol_gTC) %>%
  mutate(chla_pheoa = chl_a_nmol_gTC + pheo_a_nmol_gTC, # add new columns
         chlb_pheob = chl_b_nmol_gTC + phaeo_b_nmol_gTC,
         all_chl = chl_a_nmol_gTC + pheo_a_nmol_gTC + chl_ap_nmol_gTC, # no chlide, chl_c1 or chl_c2 in any core
         # all_diat = diato_nmol_gTC + diadino_nmol_gTC, NO DIADINO
         PI = chl_a_nmol_gTC/pheo_a_nmol_gTC, # preservation index
         # UVR_index = sed_c_nmol_gTC / (allo_nmol_gTC + diato_nmol_gTC+lutein_nmol_gTC)
         # no sed C in any core
         AD_ratio = allo_nmol_gTC / diato_nmol_gTC, 
         master_chl = (chl_a_nmol_gTC + chl_b_nmol_gTC) / (chl_ap_nmol_gTC + pheo_a_nmol_gTC + phaeo_b_nmol_gTC),
         perc_chlb = (phaeo_b_nmol_gTC / pheo_a_nmol_gTC), 
         perc_diatox = (diato_nmol_gTC/chla_pheoa))

```

## Add pigment metrics to wide dfs too
```{r}
# Adding summary pigment metrics to wide df. NOTE, only calculating for gTC, & all units are in gTC

TRK_wide <- TRK_wide %>%
   mutate(chla_pheoa = chl_a_nmol_gTC + pheo_a_nmol_gTC, 
         chlb_pheob = chl_b_nmol_gTC + phaeo_b_nmol_gTC,
         all_chl = chl_a_nmol_gTC + pheo_a_nmol_gTC + chl_ap_nmol_gTC, 
         PI = chl_a_nmol_gTC/pheo_a_nmol_gTC,
         AD_ratio = allo_nmol_gTC / diato_nmol_gTC, 
         master_chl = (chl_a_nmol_gTC + chl_b_nmol_gTC) / (chl_ap_nmol_gTC + pheo_a_nmol_gTC + phaeo_b_nmol_gTC),
         perc_chlb = (phaeo_b_nmol_gTC / pheo_a_nmol_gTC), 
         perc_diatox = (diato_nmol_gTC/chla_pheoa)) %>%
  relocate(chla_pheoa:last_col(), .after = car_z_nmol_gTC)
  
UFM_wide <- UFM_wide %>%
    mutate(chla_pheoa = chl_a_nmol_gTC + pheo_a_nmol_gTC, 
         chlb_pheob = chl_b_nmol_gTC + phaeo_b_nmol_gTC,
         all_chl = chl_a_nmol_gTC + pheo_a_nmol_gTC + chl_ap_nmol_gTC, 
         PI = chl_a_nmol_gTC/pheo_a_nmol_gTC,
         AD_ratio = allo_nmol_gTC / diato_nmol_gTC, 
         master_chl = (chl_a_nmol_gTC + chl_b_nmol_gTC) / (chl_ap_nmol_gTC + pheo_a_nmol_gTC + phaeo_b_nmol_gTC),
         perc_chlb = (phaeo_b_nmol_gTC / pheo_a_nmol_gTC), 
         perc_diatox = (diato_nmol_gTC/chla_pheoa)) %>%
  relocate(chla_pheoa:last_col(), .after = car_z_nmol_gTC)

LFM_wide <- LFM_wide %>%
    mutate(chla_pheoa = chl_a_nmol_gTC + pheo_a_nmol_gTC, 
         chlb_pheob = chl_b_nmol_gTC + phaeo_b_nmol_gTC,
         all_chl = chl_a_nmol_gTC + pheo_a_nmol_gTC + chl_ap_nmol_gTC, 
         PI = chl_a_nmol_gTC/pheo_a_nmol_gTC,
         AD_ratio = allo_nmol_gTC / diato_nmol_gTC, 
         master_chl = (chl_a_nmol_gTC + chl_b_nmol_gTC) / (chl_ap_nmol_gTC + pheo_a_nmol_gTC + phaeo_b_nmol_gTC),
         perc_chlb = (phaeo_b_nmol_gTC / pheo_a_nmol_gTC), 
         perc_diatox = (diato_nmol_gTC/chla_pheoa)) %>%
  relocate(chla_pheoa:last_col(), .after = car_z_nmol_gTC)

```


### Evaluate PI
```{r}
# visualize chl_a and PI, (doublecheck?) if PI spikes (past 1) near the surface, increase in Chl_a near depth 0 may be suspect / preservation effects may be significant. 

ggplot(UFM_short, aes(x = depth_top, y = chl_a_nmol_gTC)) +
  geom_point(size = 2, color = "darkgreen", na.rm = TRUE) +
  geom_line(color = "darkgreen", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Chl-a (nmol/gTC)") + 
  theme_minimal()

ggplot(UFM_short, aes(x = depth_top, y = PI)) +
  geom_point(size = 2, color = "darkgreen", na.rm = TRUE) +
  geom_line(color = "darkgreen", na.rm = TRUE) +
  labs(
    title = "Upper Fourmile",
    x = "Depth top (cm)",
    y = "Preservation Index") +
  theme_minimal()

ggplot(TRK_short, aes(x = depth_top, y = chl_a_nmol_gTC)) +
  geom_point(size = 2, color = "steelblue", na.rm = TRUE) +
  geom_line(color = "steelblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Chl-a (nmol/gTC)") +
  theme_minimal()

ggplot(TRK_short, aes(x = depth_top, y = chla_pheoa)) +
  geom_point(size = 2, color = "steelblue", na.rm = TRUE) +
  geom_line(color = "steelblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Total Chl-a's (nmol/gTC)") +
  theme_minimal()

ggplot(TRK_short, aes(x = depth_top, y = pheo_a_nmol_gTC)) +
  geom_point(size = 2, color = "steelblue", na.rm = TRUE) +
  geom_line(color = "steelblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Pheo-a (nmol/gTC)") +
  theme_minimal()

ggplot(TRK_short, aes(x = depth_top, y = PI)) +
  geom_point(size = 2, color = "steelblue", na.rm = TRUE) +
  geom_line(color = "steelblue", na.rm = TRUE) +
  labs(
    title = "Turkey Creek",
    x = "Depth top (cm)",
    y = "Preservation Index") +
  theme_minimal()

```

# Date Interpolation

## Pull in dates
```{r}

### read in chronology data from Flett to pull into the adms
all_dates <- read_excel("data/Flett_dates_simplified_20250917.xlsx")

# Next, organize the date data in R. This will only be used for the adms, to assign an age (year_CE) to a depth in each core (corresponding to extrap_bottom of each sample that got lead dated). The other metadata is just for checking that the code works and keeping track of things.

UFM_dates <- all_dates %>%
    filter(str_starts(sample_ID, "UFM")) %>% # select only UFM rows
    # join, removing depth top and bottom before pulling in UFM_metadata
    left_join(UFM_metadata %>% select(-depth_top, -depth_bottom), 
              by = "sample_ID") %>% 
    relocate(all_of(c(names(UFM_metadata)))) %>%
    # keep columns in the same order as in the metadata doc.
    mutate(year_CE = 2025 - extrap_bottom_age_lin)
       # NOTE !!!
       # AGES CORRESPOND TO EXTRAP BOTTOM!!
       # UFM ages derived from linear model!

  ### Original code ### repeat for TRK (make year_CE column) 
  TRK_dates <- all_dates %>%
        filter(str_starts(sample_ID, "TRK")) %>%
        left_join(TRK_metadata %>% select(-depth_top, -depth_bottom),
                  by = "sample_ID") %>%
        relocate(all_of(c(names(TRK_metadata)))) %>%
        mutate(year_CE = 2025 - extrap_bottom_age_CRS) %>%
        filter(!sample_ID %in% c("TRK2_058", "TRK2_082"))
    
         # NOTE !!!
         # AGES CORRESPOND TO EXTRAP BOTTOM!
         # TRK ages come from lin-derived CRS!!!
  
  TRK_reconstructed <- read_xlsx("data/TRK_dates_interpolated_JP.xlsx")

  # this file will look incomplete, but it's because the values for extrap_bottom 
  # and year are the only ones we really need.
  
  TRK_dates_try <- TRK_reconstructed %>%
    left_join(TRK_metadata %>% select(-depth_top, -depth_bottom),
              by = "sample_ID") %>%
    relocate(all_of(c(names(TRK_metadata)))) %>%
    mutate(year_CE = year) %>%
    filter(!is.na(extrap_bottom))
  
    # not all dates are trustworthy (just TRK2_002 - 020)
    # ages come from lin-derived CRS, correspond to extrap_bottom
    
    # the issue here is that TRK_metadata has different depth_top 
    # and _bottoms from "TRK_dates" because Flett reassigned dates for
    # TRK2_058 and TRK2_082. those are the ones we dropped, but in the 
    # adm we want the metadata depths. 
    
    # discuss with Bella/Flett how to handle splitting of the core. 
    # for now proceed with bottom portion of reconstructed core
    # (portion with no reassigned depths)...

  # repeat for LFM
  LFM_dates <- all_dates %>%
        filter(str_starts(sample_ID, "LFM")) %>%
        left_join(LFM_metadata %>% select(-depth_top, -depth_bottom),
                  by = "sample_ID") %>%
        relocate(all_of(c(names(LFM_metadata)))) %>%
        mutate(year_CE = 2025 - extrap_bottom_age_CRS)
         # NOTE !!!
         # AGES CORRESPOND TO EXTRAP BOTTOM!
         # LFM ages derived from CRS (simple)

```

## Create age-depth models
```{r}

### turn each date df into an age-depth model (adm) that tidypaleo recognizes
  
UFM_dates_clean <- UFM_dates %>% # filter to remove nas
  filter(!is.na(extrap_bottom) & !is.na(year_CE)) 

# calculate adm
UFM_adm <- age_depth_model(UFM_dates_clean,
                           depth = extrap_bottom,
                           age = year_CE)

# Repeat for LFM
LFM_dates_clean <- LFM_dates %>% # filter to remove nas
  filter(!is.na(extrap_bottom) & !is.na(year_CE)) 
LFM_adm <- age_depth_model(LFM_dates_clean,
                             depth = extrap_bottom,
                             age = year_CE)
  
# Repeat for TRK
# TRK_dates_clean <- TRK_dates %>% # filter to remove nas
#   filter(!is.na(extrap_bottom) & !is.na(year_CE)) 

TRK_adm <- age_depth_model(TRK_dates_try,
                             depth = extrap_bottom,
                             age = year_CE)

### plot the age-depth model
# very basic, but shows the trend
plot(UFM_adm)
plot(LFM_adm)
plot(TRK_adm)
```

## Interpolate dates & join to dfs - TRK
```{r}
### Interpolate dates (assign dates to nondated sections of each core)
  # first assign year_CE (for each slice)
  # calculate for every section in a .25 cm interval 
  
  # if the number ends in .0, rename the column depth "depth

# JP: Pb-210 samples are on odd samples 1-20 and even after that. 
# For pigments we want dates from even 1 - end. i.e. 0.75, 1.75, 2.75 etc.

# dates_clean length (lowest extrap_bottom)
  # UFM: 5 cm
  # LFM: 18 cm
  # TRK: 11 cm

# NOTE: SWITCHING HERE FROM EXTRAP BOTTOM TO REGULAR depth_bottom

# extrapolate whole core
TRK_interp <- predict(TRK_adm, depth = seq(0.25, 41, 0.25)) %>%
  mutate(year_CE = age) %>%
  select(depth, year_CE)

## create new columns in the interp df based on the ending digits of depth
## to easily join the interpolated ages later

  # functions to categorize depths by ending digits
  is_whole  <- function(x, tol = 1e-8) abs(x %% 1) < tol
  is_half   <- function(x, tol = 1e-8) abs(x %% 1 - 0.5) < tol
  is_three_quarters <- function(x, tol = 1e-8) abs(x %% 1 - 0.75) < tol
  
  # making new columns
  TRK_interp <- TRK_interp %>%
    mutate(
      depth_top    = ifelse(is_half(depth), depth, NA_real_),
      depth_plot   = ifelse(is_three_quarters(depth), depth, NA_real_),
      depth_bottom = ifelse(is_whole(depth), depth, NA_real_)
    ) %>%
    select(depth, year_CE, depth_top, depth_plot, depth_bottom)

# Join new columns to TRK_wide: top, plot, then bottom
TRK_wide <- TRK_wide %>%
  left_join(
    TRK_interp %>% 
      select(depth_top, year_CE) %>%
      rename(year_CE_top = year_CE),
    by = "depth_top")

TRK_wide <- TRK_wide %>%
  left_join(
    TRK_interp %>% 
      select(depth_plot, year_CE) %>%
      rename(year_CE_plot = year_CE),
    by = "depth_plot")

TRK_wide <- TRK_wide %>%
  left_join(
    TRK_interp %>% 
      select(depth_bottom, year_CE) %>%
      rename(year_CE_bottom = year_CE),
    by = "depth_bottom") 

View(TRK_wide)
TRK_wide <- TRK_wide %>%
  mutate(duration = if_else(year_CE_plot > 1980, year_CE_top - year_CE_bottom, NA_real_))

# add weight term to TRK_wide (need to do this separately because of how mutate groups)
# see gavin simpson 2018 - normalize weight against the mean(weight) to avoid changing 
# the model likelihood.

duration_mean_TRK <- mean(TRK_wide$duration, na.rm = TRUE)
TRK_wide <- mutate(TRK_wide, weight = duration / duration_mean_TRK)

# Repeat for TRK_short
TRK_short <- TRK_short %>%
  left_join(
    TRK_wide %>%
      ungroup() %>% # keep r from adding these variables twice
      select(sample_ID, year_CE_top:weight), 
    by = "sample_ID"
  )

View(TRK_wide %>% select(lake_name:bd, year_CE_top: duration))
```

## Interpolate dates & join to dfs - UFM
```{r}
# dates_clean length (lowest depth_bottom)
  # UFM: 5 cm
  # LFM: 18 cm
  # TRK: 11 cm

# NOTE: SWITCHING HERE FROM EXTRAP BOTTOM TO REGULAR depth_bottom

# interpolate adm to all UFM segments in the dated range with SIA or pigment measurements
UFM_interp <- predict(UFM_adm, depth = seq(0.25, 5, 0.25)) %>%
  mutate(year_CE = age) %>%
  select(depth, year_CE)

## create new columns in the interp df based on the ending digits of depth
## to easily join the interpolated ages later

  # making new columns
  UFM_interp <- UFM_interp %>%
    mutate(
      depth_top    = ifelse(is_half(depth), depth, NA_real_),
      depth_plot   = ifelse(is_three_quarters(depth), depth, NA_real_),
      depth_bottom = ifelse(is_whole(depth), depth, NA_real_)
    ) %>%
    select(depth, year_CE, depth_top, depth_plot, depth_bottom)

# Join new columns to UFM_wide: top, plot, then bottom
UFM_wide <- UFM_wide %>%
  left_join(
    UFM_interp %>% 
      select(depth_top, year_CE) %>%
      rename(year_CE_top = year_CE),
    by = "depth_top")

UFM_wide <- UFM_wide %>%
  left_join(
    UFM_interp %>% 
      select(depth_plot, year_CE) %>%
      rename(year_CE_plot = year_CE),
    by = "depth_plot")

UFM_wide <- UFM_wide %>%
  left_join(
    UFM_interp %>% 
      select(depth_bottom, year_CE) %>%
      rename(year_CE_bottom = year_CE),
    by = "depth_bottom") %>%
  mutate(duration = year_CE_top - year_CE_bottom) # calculate duration 

# add weight term to UFM_wide 
# see gavin simpson 2018 - normalize weight against the mean(weight) to avoid changing 
# the model likelihood.
duration_mean_UFM <- mean(UFM_wide$duration, na.rm = TRUE)
UFM_wide <- mutate(UFM_wide, weight = duration / duration_mean_UFM)

# Repeat for UFM_short
UFM_short <- UFM_short %>%
  left_join(
    UFM_wide %>%
      ungroup() %>% # keep r from adding these variables twice
      select(sample_ID, year_CE_top:weight), 
    by = "sample_ID"
  )
```

## Interpolate dates & join to dfs - LFM
```{r}
# dates_clean length (lowest depth_bottom)
  # UFM: 5 cm
  # LFM: 18 cm
  # TRK: 11 cm

# NOTE: SWITCHING HERE FROM EXTRAP BOTTOM TO REGULAR depth_bottom

# interpolate adm to all UFM segments in the dated range with SIA or pigment measurements
LFM_interp <- predict(LFM_adm, depth = seq(0.25, 18, 0.25)) %>%
  mutate(year_CE = age) %>%
  select(depth, year_CE)

## create new columns in the interp df based on the ending digits of depth
## to easily join the interpolated ages later

  # making new columns
  LFM_interp <- LFM_interp %>%
    mutate(
      depth_top    = ifelse(is_half(depth), depth, NA_real_),
      depth_plot   = ifelse(is_three_quarters(depth), depth, NA_real_),
      depth_bottom = ifelse(is_whole(depth), depth, NA_real_)
    ) %>%
    select(depth, year_CE, depth_top, depth_plot, depth_bottom)

# Join new columns to LFM_wide: top, plot, then bottom
LFM_wide <- LFM_wide %>%
  left_join(
    LFM_interp %>% 
      select(depth_top, year_CE) %>%
      rename(year_CE_top = year_CE),
    by = "depth_top")

LFM_wide <- LFM_wide %>%
  left_join(
    LFM_interp %>% 
      select(depth_plot, year_CE) %>%
      rename(year_CE_plot = year_CE),
    by = "depth_plot")

LFM_wide <- LFM_wide %>%
  left_join(
    LFM_interp %>% 
      select(depth_bottom, year_CE) %>%
      rename(year_CE_bottom = year_CE),
    by = "depth_bottom") %>%
  mutate(duration = year_CE_top - year_CE_bottom) # calculate duration 

# add weight term to LFM_wide 
# see gavin simpson 2018 - normalize weight against the mean(weight) to avoid changing 
# the model likelihood.
duration_mean_LFM <- mean(LFM_wide$duration, na.rm = TRUE)
LFM_wide <- mutate(LFM_wide, weight = duration / duration_mean_LFM)

# Repeat for LFM_short
LFM_short <- LFM_short %>%
  left_join(
    LFM_wide %>%
      ungroup() %>% # keep r from adding these variables twice
      select(sample_ID, year_CE_top:weight), 
    by = "sample_ID"
  )
```

##Interpolating sedimentation rates
```{r}
# sit down with a pen for this part... 
TRK_short <- TRK_short %>%
  mutate(s = (bd*0.5)/duration)

# check that I can get the same answer as Flett (once from a core with CRS dating and once from a core with the lin regression)
# I think the mismatch is coming from the fact that accumulation rate is calculated for the extrapolated section. let's check on TRK2_004: 

# sed accumulation rate (CRS) = 0.0291
# my est improved: 0.02792188 (~4% diff)
# my estimate: 0.02463377 (not exact...)

# TRK2_001: 0.139
# TRK2_003 corresponds to bd = 0.12656729
# TRK2_005: 0.115

# TRK2_003 represents 0.75 to 2.25cm, or 1 - 1.5
# extrap = 
(0.139*0.25+0.127*0.5+(2.25-1.5)*0.113) / (2022.359 - 2015.805)
  
  # Flett "mass in extrapolated section" column is wrong? misestimates the mass depth... 

    # this is what they did instead (assign bd of given depth to whole extrapolated section...)
    (0.127*(2.25-0.75))/(2022.359 - 2015.805) # = 0.02906622

# repeat for TRK_wide
TRK_wide <- TRK_wide %>%
  mutate(s = (bd*0.5)/duration)

# repeat for other cores
UFM_short <- UFM_short %>%
  mutate(s = (bd*0.5)/duration)
UFM_wide <- UFM_wide %>%
  mutate(s = (bd*0.5)/duration)

LFM_short <- LFM_short %>%
  mutate(s = (bd*0.5)/duration)
LFM_wide <- LFM_wide %>%
  mutate(s = (bd*0.5)/duration)

# plot TRK sedimentation rate / t
TRK_sedimentation <- ggplot(TRK_short %>% filter(!is.na(year_CE_plot), !is.na(s)), # remove na values 
  aes(x = year_CE_plot, y = s)) +
  geom_line(color = "green4", size = 1) +    # connects the dots
  geom_point(color = "green4", size = 2) +   # adds the dots
  labs(
    title = "TRK inst. sedimentation rate vs. time",
    x = "Year",
    y = expression(s~(g/cm^2/yr))            # renders s (g/cm²/yr) nicely
  ) +
  ylim(0, 0.06) + 
  theme_bw(base_size = 14)

ggsave("figures/TRK_sedimentation.png", TRK_sedimentation, width = 10, height = 5, units = "in", dpi = 300) 

# plot UFM sedimentation rate / t
UFM_sedimentation <- ggplot(UFM_short %>% filter(!is.na(year_CE_plot), !is.na(s)), # remove na values 
  aes(x = year_CE_plot, y = s)) +
  geom_line(color = "green4", size = 1) +    # connects the dots
  geom_point(color = "green4", size = 2) +   # adds the dots
  labs(
    title = "UFM inst. sedimentation rate vs. time",
    x = "Year",
    y = expression(s~(g/cm^2/yr))            # renders s (g/cm²/yr) nicely
  ) +
  ylim(0, 0.011) + 
  theme_bw(base_size = 14)

ggsave("figures/UFM_sedimentation.png", UFM_sedimentation, width = 10, height = 5, units = "in", dpi = 300) 

# plot LFM sedimentation rate / t
LFM_sedimentation <- ggplot(LFM_short %>% filter(!is.na(year_CE_plot), !is.na(s)), # remove na values 
  aes(x = year_CE_plot, y = s)) +
  geom_line(color = "green4", size = 1) +    # connects the dots
  geom_point(color = "green4", size = 2) +   # adds the dots
  labs(
    title = "LFM inst. sedimentation rate vs. time",
    x = "Year",
    y = expression(s~(g/cm^2/yr))            # renders s (g/cm²/yr) nicely
  ) +
  ylim(0, 0.0275) + 
  theme_bw(base_size = 14)

ggsave("figures/LFM_sedimentation.png", LFM_sedimentation, width = 10, height = 5, units = "in", dpi = 300) 

```

#Mass flux calculations (%C, %N)
```{r}
# add a column to TRK_short and TRK_wide with nutrient flux. C.mar after percent.C and N.mar after percent.N. 

TRK_short <- TRK_short %>%
  mutate(
    C.mar = (percent.C / 100) * s,
    N.mar = (percent.N / 100) * s) %>%
  relocate(C.mar, .after = percent.C) %>%
  relocate(N.mar, .after = percent.N)

TRK_wide <- TRK_wide %>%
  mutate(
    C.mar = (percent.C / 100) * s,
    N.mar = (percent.N / 100) * s) %>%
  relocate(C.mar, .after = percent.C) %>%
  relocate(N.mar, .after = percent.N)

# Repeat for UFM
UFM_short <- UFM_short %>%
  mutate(
    C.mar = (percent.C / 100) * s,
    N.mar = (percent.N / 100) * s) %>%
  relocate(C.mar, .after = percent.C) %>%
  relocate(N.mar, .after = percent.N)

UFM_wide <- UFM_wide %>%
  mutate(
    C.mar = (percent.C / 100) * s,
    N.mar = (percent.N / 100) * s) %>%
  relocate(C.mar, .after = percent.C) %>%
  relocate(N.mar, .after = percent.N)

# Repeat for LFM
LFM_short <- LFM_short %>%
  mutate(
    C.mar = (percent.C / 100) * s,
    N.mar = (percent.N / 100) * s) %>%
  relocate(C.mar, .after = percent.C) %>%
  relocate(N.mar, .after = percent.N)

LFM_wide <- LFM_wide %>%
  mutate(
    C.mar = (percent.C / 100) * s,
    N.mar = (percent.N / 100) * s) %>%
  relocate(C.mar, .after = percent.C) %>%
  relocate(N.mar, .after = percent.N)
```

## Visualize ways of showing ∆C / t
```{r}

# visualize Cmar, s, and %C in TRK. 
ggplot(TRK_short %>% filter(!is.na(year_CE_plot), !is.na(s)), # remove na values 
  aes(x = year_CE_plot, y = s)) +
  geom_line(color = "green4", size = 1) +    # connects the dots
  geom_point(color = "green4", size = 2) +   # adds the dots
  labs(
    title = "TRK inst. sedimentation rate vs. time",
    x = "Year",
    y = expression(s~(g/cm^2/yr))            # renders s (g/cm²/yr) nicely
  ) +
  ylim(0, 0.06) + 
  theme_bw(base_size = 14)

ggplot(TRK_short %>% filter(!is.na(year_CE_plot), !is.na(s)), # remove na values 
  aes(x = year_CE_plot, y = C.mar)) +
  geom_line(color = "green4", size = 1) +    # connects the dots
  geom_point(color = "green4", size = 2) +   # adds the dots
  labs(
    title = "TRK C MAR vs. time",
    x = "Year",
    y = expression("carbon MAR"~(g/cm^2/yr))    
  ) +
  ylim(0, 0.01) + 
  theme_bw(base_size = 14)

ggplot(TRK_short %>% filter(!is.na(year_CE_plot), !is.na(s)), # remove na values 
  aes(x = year_CE_plot, y = percent.C)) +
  geom_line(color = "green4", size = 1) +    # connects the dots
  geom_point(color = "green4", size = 2) +   # adds the dots
  labs(
    title = "TRK percent C vs. time",
    x = "Year",
    y = "% Carbon") +
  ylim(0, 20) + 
  theme_bw(base_size = 14)

```

#Mass flux calculations (pigments)
```{r}
# start with TRK
TRK_wide <- TRK_wide %>%
  mutate(
    fuco_flux = fuco_nmol_gDM * s, 
    allo_flux = allo_nmol_gDM * s, 
    diato_flux = diato_nmol_gDM * s, 
    lutein_flux = lutein_nmol_gDM * s, 
    cantha_flux = cantha_nmol_gDM * s, 
    chl_b_flux = chl_b_nmol_gDM * s, 
    chl_a_flux = chl_a_nmol_gDM * s, 
    chl_ap_flux = chl_ap_nmol_gDM * s, 
    echine_flux = echine_nmol_gDM * s, 
    phaeo_b_flux = phaeo_b_nmol_gDM * s, 
    pheo_a_flux = pheo_a_nmol_gDM * s, 
    b_car_flux = b_car_nmol_gDM * s, 
    .after = perc_diatox)

flux_columns <- c(
  "fuco_flux", "allo_flux", "diato_flux", "lutein_flux", "cantha_flux",
  "chl_b_flux", "chl_a_flux", "chl_ap_flux", "echine_flux", "phaeo_b_flux",
  "pheo_a_flux", "b_car_flux")

# join just those columns from TRK_wide into TRK_short
TRK_short <- TRK_short %>%
  left_join(TRK_wide %>% 
              ungroup() %>% 
              select(sample_ID, all_of(flux_columns)),
            by = "sample_ID") %>%
    relocate(all_of(flux_columns), .after = perc_diatox)

# Repeat for UFM
UFM_wide <- UFM_wide %>%
  mutate(
    fuco_flux = fuco_nmol_gDM * s, 
    allo_flux = allo_nmol_gDM * s, 
    diato_flux = diato_nmol_gDM * s, 
    lutein_flux = lutein_nmol_gDM * s, 
    cantha_flux = cantha_nmol_gDM * s, 
    chl_b_flux = chl_b_nmol_gDM * s, 
    chl_a_flux = chl_a_nmol_gDM * s, 
    chl_ap_flux = chl_ap_nmol_gDM * s, 
    echine_flux = echine_nmol_gDM * s, 
    phaeo_b_flux = phaeo_b_nmol_gDM * s, 
    pheo_a_flux = pheo_a_nmol_gDM * s, 
    b_car_flux = b_car_nmol_gDM * s, 
    .after = perc_diatox)

UFM_short <- UFM_short %>%
  left_join(UFM_wide %>% 
              ungroup() %>% 
              select(sample_ID, all_of(flux_columns)),
            by = "sample_ID") %>%
    relocate(all_of(flux_columns), .after = perc_diatox)

# Repeat for LFM
LFM_wide <- LFM_wide %>%
  mutate(
    fuco_flux = fuco_nmol_gDM * s, 
    allo_flux = allo_nmol_gDM * s, 
    diato_flux = diato_nmol_gDM * s, 
    lutein_flux = lutein_nmol_gDM * s, 
    cantha_flux = cantha_nmol_gDM * s, 
    chl_b_flux = chl_b_nmol_gDM * s, 
    chl_a_flux = chl_a_nmol_gDM * s, 
    chl_ap_flux = chl_ap_nmol_gDM * s, 
    echine_flux = echine_nmol_gDM * s, 
    phaeo_b_flux = phaeo_b_nmol_gDM * s, 
    pheo_a_flux = pheo_a_nmol_gDM * s, 
    b_car_flux = b_car_nmol_gDM * s, 
    .after = perc_diatox)

LFM_short <- LFM_short %>%
  left_join(LFM_wide %>% 
              ungroup() %>% 
              select(sample_ID, all_of(flux_columns)),
            by = "sample_ID") %>%
    relocate(all_of(flux_columns), .after = perc_diatox)

```

#All parameter vis
```{r}

# At a glance look at all parameters in an individual core

# Start with TRK

TRK_short %>%
  pivot_longer(d13C:perc_diatox) %>%
  ggplot(aes(x=depth_top, y=value, color=name))+
  geom_point()+
  geom_line()+
  geom_smooth(method="gam")+ # "really easy to plot a gam"
  facet_wrap(.~name, scales="free_y")+
  theme(legend.position="none")

UFM_short %>%
  pivot_longer(d13C:perc_diatox) %>%
  ggplot(aes(x=depth_top, y=value, color=name))+
  geom_point()+
  geom_line()+
  facet_wrap(.~name, scales="free_y")+
  theme(legend.position="none")

LFM_short %>%
  pivot_longer(d13C:perc_diatox) %>%
  ggplot(aes(x=depth_top, y=value, color=name))+
  geom_point()+
  geom_line()+
  facet_wrap(.~name, scales="free_y")+
  theme(legend.position="none")

```

# Export
```{r}
# Combine all lakes into one data frame
all_lakes <- bind_rows(UFM_short, LFM_short, TRK_short)

# export important dfs as csvs 
write.csv(all_lakes, file="output/all_lakes.csv")
write.csv(LFM_wide, file="output/LFM_wide.csv")
write.csv(UFM_wide, file="output/UFM_wide.csv")
write.csv(TRK_wide, file="output/TRK_wide.csv")
write.csv(LFM_short, file="output/LFM_short.csv")
write.csv(UFM_short, file="output/UFM_short.csv")
write.csv(TRK_short, file="output/TRK_short.csv")

# save the age-depth models too
saveRDS(UFM_adm, "output/UFM_adm.rds")
saveRDS(LFM_adm, "output/LFM_adm.rds")
saveRDS(TRK_adm, "output/TRK_adm.rds")
```