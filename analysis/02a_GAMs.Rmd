---
title: "02a_GAMs"
author: "Julia Pop"
date: "2025-09-22"
output: html_document
---

```{r setup, include=FALSE}
# code to troublesheet file path issues. 
# By default, knitr uses the folder containing the .Rmd file as
# the working directory. This code allows us to set the folder
# with our .rProj in it as the root. 

# find_root looks upwards from the .Rmd until it finds a file or
# folder that matches the criteria "folder with a .Rproj file in
# it."

knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::is_rstudio_project))
```

#Libraries -- add these here
```{r}
source("scripts/libraries.R")
source("scripts/GAM_functions.R")
```

**NOTE! use the short files for the gams unless interested in comparing pigment units (g TC vs g dry mass)**

## Pull in data
```{r}
all_lakes <- read.csv("output/all_lakes.csv")

UFM_short <- read.csv("output/UFM_short.csv")
LFM_short <- read.csv("output/LFM_short.csv")
TRK_short <- read.csv("output/TRK_short.csv")
```

### Adding a weight term

Added the weight term already in 00_data_input_and_manipulation.Rmd. Instead of calculating weights with interval = lag(), weight corresponds to the duration captured by each slice, as in Simpson 2018. Addresses HETERO - SKA - DA - STI - CITY.

**Questions:** 

- Gamma distributed vs. gaussian distributed data... 

### GAMs- Bella's way, but with Julias annotations: 
Bella's way without annotations is reproduced below.
```{r}
### FAMILY:
# For our purposes, family = gaussian (normal) for isotopes 
# (they can have negative and positive values), and
# family = gamma for concentrations and rates
# in that case the mean of the response variable is restricted to [0,inf)... 

### K (sets the maximum # of bases for our spline): 

# Our dataset is very small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(LFM_short$year_CE_plot)) # 18 observations. 
    
# try with and without corCAR1, then examine the residuals. 
mod_d15N_LFM <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     # does family correspond to the data or their residuals? 
                     # check with bella
                     data = LFM_short,
                     weight = weight, 
                     method = "REML")

mod_d15N_LFM_CAR1 <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     # does family correspond to the data or their residuals? 
                     # check with bella
                     data = LFM_short,
                     weight = weight, 
                     correlation = corCAR1(form = ~ year_CE_plot),
                     method = "REML")
                 # correlation = corCAR1(form = ~ year_CE_plot)


resid_values <- residuals(mod_d15N_LFM$lme, type = "normalized")       # no CAR(1)
resid_values_CAR1 <- residuals(mod_d15N_LFM_CAR1$lme, type = "normalized")   # with CAR(1)
all.equal(resid_values, resid_values_CAR1)  # Check if they are identical
# residuals are basically equal, so CAR(1) isn't doing much

# examine again using AIC:
AIC(mod_d15N_LFM$lme)   # without CAR(1): -6.85481
AIC(mod_d15N_LFM_CAR1$lme) # without CAR(1): -4.845512
# lower AIC = better? 
# AIC=2k−2ln(L), where k = # parameters, L = likelihood.

# stopped here!!!
## summary object for use in document
d15NSumm_LFM <- summary(mod_d15N_LFM$gam)
d15NSumm_LFM #Gives you the P values, degrees of freedom...
print.summary.gam(d15NSumm_LFM)

### Check diagnostics. You might need to adjust model
gam.check(mod_d15N_LFM$gam)
```


### GAMs- Bella's way
```{r}
### family=Gamma(link="log") for gamma distributed errors
### family = gaussian(link = "identity") for normal data with negative values
mod_d15N_LFM <- gamm(d15N ~ s(year_CE, k = 10),
                     family = gaussian(link = "identity"), 
                     data = LFM_short,
                     correlation = corCAR1(form = ~ year_CE), method = "REML")

## summary object for use in document
d15NSumm_LFM <- summary(mod_d15N_LFM$gam)
d15NSumm_LFM #Gives you the P values, degrees of freedom...
print.summary.gam(d15NSumm_LFM)

### Check diagnostics. You might need to adjust model
gam.check(mod_d15N_LFM$gam)

N <- 300    # number of points at which to evaluate the splines

### Second, if you're only concerned about the response, include "response" in type of predict()
d15NYear_LFM <- with(LFM_short,
                     data.frame(year_CE = seq(min(year_CE, na.rm=TRUE), max(year_CE, na.rm=TRUE), length.out = 200)))
d15NYear_LFM <- cbind(d15NYear_LFM,
                      data.frame(predict(mod_d15N_LFM$gam, d15NYear_LFM,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale (i.e., log)
d15NYear_LFM <- transform(d15NYear_LFM, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_LFM$lake_ID <- 'LFM'

## Plot fitted trends
del15N_fitted_S <- ggplot(d15NYear_LFM, aes(x = year_CE, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_CE),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = LFM_short, mapping = aes(x = year_CE, y = d15N), inherit.aes = FALSE) +
  geom_line() 
del15N_fitted_S

#Note that this quick & dirty way basically achieves something similar but the 
#band around the trend looks different. This way is fine if you are just trying 
#to make some quick plots for GREEBS
LFM_short %>%
  ggplot(aes(x=year_CE,y=d15N))+
  geom_point()+
  geom_smooth(method="gam")


############
############
#First derivatives using gratia packageinstead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short,
                     data.frame(year_CE = seq(min(year_CE, na.rm=TRUE), max(year_CE, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better


# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_CE") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short) +
  geom_point(aes(year_CE, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_d15N.png",
       dpi=600,
       height=5,
       width=5,
       units="in")


# FOR WHAT IT'S WORTH... 
# Here is old code I have modified from Gavin Simpson, basically identical to what Cale provided.
# https://www.fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/
# Make the same plot as above but in base R. You may prefer ggplot2 (I do, these)
Term <- "year_CE"
m2.d <- Deriv(mod_d15N_LFM)
m2.dci <- confint(m2.d, term = "year_CE")
m2.dsig <- signifD(d15NYear_LFM$fit,
                   d = m2.d[[Term]]$deriv,
                   m2.dci[[Term]]$upper,
                   m2.dci[[Term]]$lower)



ylim <- with(d15NYear_LFM, range(upper, lower, fit))
ylab <- expression(paste(delta^{15}, "N (‰)"))

plot(fit ~ year_CE, data = d15NYear_LFM, type = "n", ylab = ylab, ylim = ylim)
lines(fit ~ year_CE, data = d15NYear_LFM)
lines(upper ~ year_CE, data = d15NYear_LFM, lty = "dashed")
lines(lower ~ year_CE, data = d15NYear_LFM, lty = "dashed")
lines(unlist(m2.dsig$incr) ~ year_CE, data = d15NYear_LFM, col = "blue", lwd = 3)
lines(unlist(m2.dsig$decr) ~ year_CE, data = d15NYear_LFM, col = "red", lwd = 3)


decr<-data.frame(unlist(m2.dsig$decr), d15NYear_LFM$age_sky) %>%
  rename(value=unlist.m2.dsig.decr.,
         age_sky=del15NYear_S.age_sky)
```

### Gams - Cale's way
```{r}

m.beta <- gam(d15N ~s(year_CE, k = 10), # this is simply the trend by date
              data = LFM_short, ## the data used
              family = gaussian(link = "identity"),  # use Gaussian for roughly normal data
                  ## Use Gamma for concentration data
              bs='tp',## spline - thin plate is ok for simple models like this 
              method="REML", ## method - always use REML for gam
              weights = weight) ## here we add the weight term

# now check if the gam is good
summary(m.beta)
plot(m.beta)
gam.check(m.beta)

### now that you have a good model, you need to predict new data over your original data
### before we predict, we need to transform the data to deal
## with the Gamma family
fam<-family(m.beta)
fam
str(fam) 
ilink <- fam$linkinv
ilink 
Gamma()$linkinv 
ilink <- family(m.beta)$linkinv 

### now we predict 
pred <- with(LFM_short, data.frame(year_CE = seq(min(year_CE,na.rm=TRUE), max(year_CE,na.rm=TRUE), ## this is making fake dates to model through
                                        length.out = 200))) ### 200-300 are usually good numbers of data points
pred <- cbind(pred,
              data.frame(predict(m.beta, pred, se.fit = TRUE))) # add the prediction to your data
## now we use the ilink to account for the transformation
pred <- transform(pred, fit = ilink(fit), 
                  upper = ilink(fit + (2 * se.fit)),
                  lower = ilink(fit - (2 * se.fit))) ## and this creates confidence intervals for your model



## Derive from your model!
dt.Der<-Deriv(m.beta) ## derive
plot(dt.Der, sizer = TRUE)
Term<-"year_CE" 
dt.dci<-confint(dt.Der, term = Term) ## make confidence intervals
dt.dsig<-signifD(pred$fit, d = dt.Der[[Term]]$deriv,
                 dt.dci[[Term]]$upper, dt.dci[[Term]]$lower) ### show significance

### now we make a simple plot
p.beta <- 
  ggplot(LFM_short)+
  geom_point(aes(year_CE, d15N))+
  geom_ribbon(data=pred, aes(ymin=lower, ymax=upper, x=year_CE), alpha=0.2)+
  geom_line(data=pred, aes(year_CE, fit), linewidth=1, color="black")+
  geom_line(data=pred, aes(year_CE, dt.dsig$decr), color="#CC9933", lwd=2)+ ## this highlights what areas have significant changes
  geom_line(data=pred, aes(year_CE, dt.dsig$incr), color="#CC9933", lwd=2)+
  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab('d15N')+
  xlab('Year')+
  theme_bw()
p.beta



```

# Compare model fits
```{r}

hist(LFM_short$phaeo_b_nmol_gTC)
hist(log(LFM_short$phaeo_b_nmol_gTC))


m.pheob.normal <- gam(phaeo_b_nmol_gTC ~s(year_CE, k = 10), # this is simply the trend by date
              data = LFM_short, ## the data used
              family = gaussian(link = "identity"),  # use Gaussian for roughly normal data
                  ## Use Gamma for concentration data
              bs='tp',## spline - thin plate is ok for simple models like this 
              method="REML", ## method - always use REML for gam
              weights = weight) ## here we add the weight term

m.pheob.gamma <- gam(phaeo_b_nmol_gTC ~s(year_CE, k = 10), # this is simply the trend by date
              data = LFM_short, ## the data used
              family=Gamma(link="log"),  # use Gaussian for roughly normal data
                  ## Use Gamma for concentration data
              bs='tp',## spline - thin plate is ok for simple models like this 
              method="REML", ## method - always use REML for gam
              weights = weight) ## here we add the weight term

par(mfrow = c(2, 2))
gam.check(m.pheob.normal)
par(mfrow = c(2, 2))
gam.check(m.pheob.gamma)

summary(m.pheob.normal)
summary(m.pheob.gamma)

AIC(m.pheob.normal, m.pheob.gamma)

par(mfrow = c(1, 2))
plot(fitted(m.pheob.normal), resid(m.pheob.normal), main = "Gaussian")
abline(h = 0, col = "red")
plot(fitted(m.pheob.gamma), resid(m.pheob.gamma), main = "Gamma(log)")
abline(h = 0, col = "red")

# The deviance explained in the gamma model is higher but the AIC is very similar.
# Let's look at the model fits and decide? 
```

## Pheo b normal/gaussian family
```{r}

### now that you have a good model, you need to predict new data over your original data
### before we predict, we need to transform the data to deal
## with the Gamma family
fam<-family(m.pheob.normal)
fam
str(fam) 
ilink <- fam$linkinv
ilink 
Gamma()$linkinv 
ilink <- family(m.pheob.normal)$linkinv 

### now we predict 
pred <- with(LFM_short, data.frame(year_CE = seq(min(year_CE,na.rm=TRUE), max(year_CE,na.rm=TRUE), ## this is making fake dates to model through
                                        length.out = 200))) ### 200-300 are usually good numbers of data points
pred <- cbind(pred,
              data.frame(predict(m.pheob.normal, pred, se.fit = TRUE))) # add the prediction to your data
## now we use the ilink to account for the transformation
pred <- transform(pred, fit = ilink(fit), 
                  upper = ilink(fit + (2 * se.fit)),
                  lower = ilink(fit - (2 * se.fit))) ## and this creates confidence intervals for your model



## Derive from your model!
dt.Der<-Deriv(m.pheob.normal) ## derive
plot(dt.Der, sizer = TRUE)
Term<-"year_CE" 
dt.dci<-confint(dt.Der, term = Term) ## make confidence intervals
dt.dsig<-signifD(pred$fit, d = dt.Der[[Term]]$deriv,
                 dt.dci[[Term]]$upper, dt.dci[[Term]]$lower) ### show significance

### now we make a simple plot
  ggplot(LFM_short)+
  geom_point(aes(year_CE, phaeo_b_nmol_gTC))+
  geom_ribbon(data=pred, aes(ymin=lower, ymax=upper, x=year_CE), alpha=0.2)+
  geom_line(data=pred, aes(year_CE, fit), linewidth=1, color="black")+
  geom_line(data=pred, aes(year_CE, dt.dsig$decr), color="#CC9933", lwd=2)+ ## this highlights what areas have significant changes
  geom_line(data=pred, aes(year_CE, dt.dsig$incr), color="#CC9933", lwd=2)+
  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab('pheo b - gaussian family')+
  xlab('Year')+
  theme_bw()
```


## Pheo b gamma family
```{r}

### now that you have a good model, you need to predict new data over your original data
### before we predict, we need to transform the data to deal
## with the Gamma family
fam<-family(m.pheob.gamma)
fam
str(fam) 
ilink <- fam$linkinv
ilink 
Gamma()$linkinv 
ilink <- family(m.pheob.gamma)$linkinv 

### now we predict 
pred <- with(LFM_short, data.frame(year_CE = seq(min(year_CE,na.rm=TRUE), max(year_CE,na.rm=TRUE), ## this is making fake dates to model through
                                        length.out = 200))) ### 200-300 are usually good numbers of data points
pred <- cbind(pred,
              data.frame(predict(m.pheob.gamma, pred, se.fit = TRUE))) # add the prediction to your data
## now we use the ilink to account for the transformation
pred <- transform(pred, fit = ilink(fit), 
                  upper = ilink(fit + (2 * se.fit)),
                  lower = ilink(fit - (2 * se.fit))) ## and this creates confidence intervals for your model



## Derive from your model!
dt.Der<-Deriv(m.pheob.gamma) ## derive
plot(dt.Der, sizer = TRUE)
Term<-"year_CE" 
dt.dci<-confint(dt.Der, term = Term) ## make confidence intervals
dt.dsig<-signifD(pred$fit, d = dt.Der[[Term]]$deriv,
                 dt.dci[[Term]]$upper, dt.dci[[Term]]$lower) ### show significance

### now we make a simple plot
  ggplot(LFM_short)+
  geom_point(aes(year_CE, phaeo_b_nmol_gTC))+
  geom_ribbon(data=pred, aes(ymin=lower, ymax=upper, x=year_CE), alpha=0.2)+
  geom_line(data=pred, aes(year_CE, fit), linewidth=1, color="black")+
  geom_line(data=pred, aes(year_CE, dt.dsig$decr), color="#CC9933", lwd=2)+ ## this highlights what areas have significant changes
  geom_line(data=pred, aes(year_CE, dt.dsig$incr), color="#CC9933", lwd=2)+
  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab('pheo b - gaussian family')+
  xlab('Year')+
  theme_bw()

# Gaussian family seems to fit the data a bit better to me.
# First derivatives don't show evidence for an acceleration in the trend
```